<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PG Trigger Manager Example</title>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        #messages { border: 1px solid #ccc; padding: 10px; min-height: 150px; overflow-y: scroll; }
        .message { margin-bottom: 5px; padding: 5px; background-color: #f0f0f0; }
    </style>
</head>
<body>
    <h1>PG Trigger Manager Example</h1>

    <p>æ‰“é–‹ç€è¦½å™¨çš„é–‹ç™¼è€…å·¥å…· (F12) æŸ¥çœ‹æ§åˆ¶å°è¼¸å‡ºï¼Œä»¥è§€å¯Ÿè³‡æ–™åº«äº‹ä»¶ã€‚</p>

    <h2>è§¸ç™¼å™¨ç®¡ç†</h2>
    <label for="tableName">è³‡æ–™è¡¨åç¨±:</label>
    <input type="text" id="tableName" value="users">
    <button id="createTrigger">å»ºç«‹è§¸ç™¼å™¨</button>
    <button id="listTriggers">åˆ—å‡ºè§¸ç™¼å™¨</button>
    <button id="deleteTrigger">åˆªé™¤è§¸ç™¼å™¨</button>

    <h2>è³‡æ–™åº«äº‹ä»¶</h2>
    <div id="messages"></div>

    <script type="module">
    import { createTRPCProxyClient, httpBatchLink, wsLink, splitLink } from 'https://cdn.jsdelivr.net/npm/@trpc/client@10.45.2/dist/index.mjs';
    import { observable } from 'https://cdn.jsdelivr.net/npm/@trpc/server@10.45.2/dist/observable.mjs';

    // ç‚ºäº†ç°¡åŒ–ç¯„ä¾‹ï¼Œé€™è£¡ç›´æ¥å¼•å…¥å¾Œç«¯çš„ AppRouter å‹åˆ¥
    // åœ¨å¯¦éš›å°ˆæ¡ˆä¸­ï¼Œæ‚¨å¯èƒ½æœƒå¾ä¸€å€‹å…±äº«çš„å¥—ä»¶ä¸­å¼•å…¥é€™å€‹å‹åˆ¥

    // æ¨¡æ“¬ AppRouter çš„å‹åˆ¥ï¼Œå› ç‚ºæˆ‘å€‘ç„¡æ³•ç›´æ¥å¾å¾Œç«¯å¼•å…¥
    // åœ¨å¯¦éš›å°ˆæ¡ˆä¸­ï¼Œé€™æ‡‰è©²æ˜¯å¾å¾Œç«¯ç”Ÿæˆçš„å‹åˆ¥å®šç¾©
    type MockAppRouter = {
        trigger: {
            create: {
                mutate: (input: { tableName: string }) => Promise<{ success: boolean; message: string; }>,
            },
            list: {
                query: () => Promise<Array<{ trigger_name: string; table_name: string; }>>,
            },
            delete: {
                mutate: (input: { tableName: string }) => Promise<{ success: boolean; message: string; }>,
            },
        },
        onDbEvent: {
            subscribe: (input: undefined, opts: { onData: (data: any) => void; onError: (err: any) => void; }) => void,
        },
    };

    const backendUrl = 'http://localhost:5000';
    const wsUrl = 'ws://localhost:5000';

    const client = createTRPCProxyClient<MockAppRouter>({
        links: [
            splitLink({
                condition: (op) => op.type === 'subscription',
                true: wsLink({
                    url: wsUrl,
                }),
                false: httpBatchLink({
                    url: backendUrl + '/trpc',
                }),
            }),
        ],
    });

    const tableNameInput = document.getElementById('tableName') as HTMLInputElement;
    const createTriggerBtn = document.getElementById('createTrigger') as HTMLButtonElement;
    const listTriggersBtn = document.getElementById('listTriggers') as HTMLButtonElement;
    const deleteTriggerBtn = document.getElementById('deleteTrigger') as HTMLButtonElement;
    const messagesDiv = document.getElementById('messages') as HTMLDivElement;

    function addMessage(text: string, type: 'info' | 'error' = 'info') {
        const p = document.createElement('p');
        p.className = 'message';
        if (type === 'error') {
            p.style.color = 'red';
        }
        p.innerText = text;
        messagesDiv.prepend(p);
    }

    createTriggerBtn.addEventListener('click', async () => {
        const tableName = tableNameInput.value;
        if (!tableName) {
            addMessage('è«‹è¼¸å…¥è³‡æ–™è¡¨åç¨±ï¼', 'error');
            return;
        }
        try {
            const result = await client.trigger.create.mutate({ tableName });
            addMessage(`å»ºç«‹è§¸ç™¼å™¨çµæœ: ${result.message}`);
        } catch (error) {
            addMessage(`å»ºç«‹è§¸ç™¼å™¨å¤±æ•—: ${error instanceof Error ? error.message : String(error)}`, 'error');
        }
    });

    listTriggersBtn.addEventListener('click', async () => {
        try {
            const triggers = await client.trigger.list.query();
            if (triggers.length === 0) {
                addMessage('ç›®å‰æ²’æœ‰è§¸ç™¼å™¨ã€‚');
            } else {
                addMessage('ç›®å‰è§¸ç™¼å™¨åˆ—è¡¨:');
                triggers.forEach(t => addMessage(`- ${t.trigger_name} (è¡¨: ${t.table_name})`));
            }
        } catch (error) {
            addMessage(`åˆ—å‡ºè§¸ç™¼å™¨å¤±æ•—: ${error instanceof Error ? error.message : String(error)}`, 'error');
        }
    });

    deleteTriggerBtn.addEventListener('click', async () => {
        const tableName = tableNameInput.value;
        if (!tableName) {
            addMessage('è«‹è¼¸å…¥è³‡æ–™è¡¨åç¨±ï¼', 'error');
            return;
        }
        try {
            const result = await client.trigger.delete.mutate({ tableName });
            addMessage(`åˆªé™¤è§¸ç™¼å™¨çµæœ: ${result.message}`);
        } catch (error) {
            addMessage(`åˆªé™¤è§¸ç™¼å™¨å¤±æ•—: ${error instanceof Error ? error.message : String(error)}`, 'error');
        }
    });

    // è¨‚é–±è³‡æ–™åº«äº‹ä»¶
    addMessage('æ­£åœ¨è¨‚é–±è³‡æ–™åº«äº‹ä»¶...');
    client.onDbEvent.subscribe(undefined, {
        onData(event) {
            addMessage(`ğŸ‰ æ”¶åˆ°è³‡æ–™åº«äº‹ä»¶: ${JSON.stringify(event, null, 2)}`);
            console.log('ğŸ‰ New database event received:', event);
        },
        onError(err) {
            addMessage(`è¨‚é–±éŒ¯èª¤: ${err instanceof Error ? err.message : String(err)}`, 'error');
            console.error('Subscription error:', err);
        },
    });

    addMessage('å‰ç«¯æ‡‰ç”¨å·²å•Ÿå‹•ã€‚');
</script>
</body>
</html>